\documentclass[10pt,twocolumn]{article}
\usepackage[british]{babel}
%\usepackage[utf8]{inputenc}
\usepackage[margin=2.25cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}
\usepackage[table,xcdraw]{xcolor}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{booktabs}
\usepackage{titlesec}

%argmin, argmax
\usepackage{amsmath}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\diag}{diag}

\newcommand{\mmatrix}[1]{\boldsymbol{#1}}
\newcommand{\mvec}[1]{\boldsymbol{#1}}

\graphicspath{ {./images/} }

\usepackage{pgfplots}
\pgfplotsset{compat=1.16}

\usepackage{titlesec}
\titleformat{\section}
{\normalfont\Large\bfseries}{Group~\thesection.}{1em}{}

%\titleformat*{\subsection}{\normalsize\bfseries} % make subsection title smaller
\titleformat{\subsection}
{\normalfont\normalsize\bfseries}{\thesubsection}{.5em}{}

\renewcommand\thesubsection{\Roman{section}. \alph{subsection})}
\renewcommand{\thesection}{\Roman{section}}

\newcommand{\footurl}[1]{\footnote{\url{#1}}}
\newcommand{\todo}[1]{\textcolor{blue}{[\textbf{TODO: #1}]} } 
\usepackage[en-GB]{datetime2}   % for pretty date
\DTMlangsetup[en-GB]{ord=raise} % for pretty date

\usepackage{tikz}
\usepackage{tikz-qtree}
\usetikzlibrary{matrix}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{arrows,automata}
\colorlet{pinkyred}{pink!50!red}

\usepackage{amsmath}
\DeclareMathOperator{\score}{score}

\setlength{\columnsep}{2em}

\title{Report for LAB6: Omics Applications \\
\Large{Bioinformatics}}
\author{ Ricardo Brancas    \\ 83557
    \and Margarida Ferreira \\ 80832
    \and Felipe Gorostiaga  \\ 95383
    \and Benedict Schubert  \\ 95034}

\date{\today}

\begin{document}
\maketitle

<<include=FALSE,cache=FALSE>>=
library(ggplot2)
library(RColorBrewer)
library(edgeR)
library(stringr)
library(ggpubr)
library(survival)
library(ggfortify)
library(knitr)
library(tidyr)
opts_chunk$set(echo=FALSE)
options(digits=4)
@

<<echo=FALSE,cache=TRUE,cache.lazy=FALSE>>=
read_counts = read.csv('TCGA_BRCA_Gene_ReadCounts.txt', sep='\t', header=TRUE, row.names = 1)
counts_histogram = data.frame(counts=colSums(read_counts))
counts_comparison = read.csv('outputs/counts_comparison.csv', sep=',', header=TRUE)
annotations = read.delim('TCGA_BRCA_ClinicalAnnotation.txt', header=TRUE, row.names=1)
rownames(annotations) = str_replace(str_replace(rownames(annotations), '-', '.'), '-', '.')

ESR1 = t(read_counts[c("ESR1"),])
ESR2 = t(read_counts[c("ESR2"),])
PGR = t(read_counts[c("PGR"),])
ERBB2 = t(read_counts[c("ERBB2"),])

groups = as.numeric(substr(colnames(read_counts), nchar(colnames(read_counts))-1, nchar(colnames(read_counts))-1))

Tissue <- factor(groups)
Patient <- factor(substr(colnames(read_counts), 0, 12))
Estrogen <- addNA(annotations$Estrogen.Receptor[Patient])
Progesterone <- addNA(annotations$Progesterone.Receptor[Patient])
HER2 <- addNA(annotations$HER2[Patient])
Status <- annotations$Vital.status[Patient]
PAM50 <- annotations$PAM50[Patient]
LastFollowUp <- annotations$Days.to.last.follow.up[Patient]
DaysToDeath <- annotations$Days.to.death[Patient]

data_g1 <- read_counts %>% gather() %>% extract(key, c("tissue"), regex="([01]).$", remove=FALSE, convert=TRUE)
data_g1$tissue = factor(data_g1$tissue)

data_g3 <- data.frame(ESR1, ESR2, PGR, ERBB2, Estrogen, Progesterone, HER2)

@


%paired end read -> reason why we have 2 FASTQ files.
\section{}

\subsection{Quality assessment of FASTQ}
In figure~\ref{fig:sequence-quality} we present the per base sequence quality graphs obtained using the tool \textsc{FastQC}. The sequences have reasonably good quality scores, although there is some disparity between them. In particular the first sequence has slightly better quality than the second one, which is something one should be aware of.

\begin{figure}[ht]
     \centering
     \begin{subfigure}[b]{0.9\columnwidth}
         \centering
         \includegraphics[width=\textwidth]{outputs/quality1.png}
         \caption{Quality graph for raw sequence 1.}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.9\columnwidth}
         \centering
         \includegraphics[width=\textwidth]{outputs/quality2.png}
         \caption{Quality graph for raw sequence 2.}
     \end{subfigure}
        \caption{Quality graphs for the raw sequences, as obtained in \textsc{FastQC}.}
        \label{fig:sequence-quality}
\end{figure}

\subsection{Estimated gene expression vs. provided read counts}
We chose to use the aligner \textsc{Kallisto}, together with the annotated human transcriptome from Ensembl \footurl{ftp://ftp.ensembl.org/pub/release-98/fasta/homo_sapiens/cdna/Homo_sapiens.GRCh38.cdna.all.fa.gz}.
We chose the cDNA sequences, as advised in the Kallisto FAQ \footurl{https://pachterlab.github.io/kallisto/faq}.

To compare the transcript expression with the gene expression counts given, we downloaded a mapping from the Ensembl transcript identifiers to gene names. We used  Ensembl Biomart \footurl{http://www.ensembl.org/biomart/martview/a797838aa8255de1efa6fb6d11322eb5} to get this mapping. We then took the transcript count estimates and the mapping and created a summarised table containing the total estimated number of reads for each gene. Finally, comparing this table with the read count table we were given, results in the graph in figure~\ref{fig:count-comparison}. Figure~\ref{fig:count-comparison}a shows all the estimated and provided read counts plotted against each other: each black mark represents a gene, the value on the y-axis is the provided read count, while the value on the x axis is the estimated read count; therefore, the closer a mark is to the \(y=x\) line, the better the estimation. Analysing this graph, we can see that most genes are correctly estimated, as most marks lie within the \(y=x\) line. Most outliers are from read counts of 0 which most likely represents a mismatch between the transcript identifiers and the gene names. In Figure~\ref{fig:count-comparison}b we show the same data, this time plotted in logarithmic scale so the values are more easily seen. Note that, in order to plot in a logarithmic scale, all the zero-valued read counts must be removed. In this plot we can again see that most of the estimates are accurate, even though there are a few outliers. We can also see that it appears that the higher the read count the better the estimation. This however is no true: what we are seeing is a result of the logarithmic scale: the errors are of the same order of magnitude, but since the scale is much larger, they seem smaller when compared to the actual read count values.

%TODO MACF: Add y=x line to the plots?
\todo{MACF: Add y=x line to the plots?}

<<count-comparison, fig.pos='ht', fig.width=5, fig.height=4, fig.ncol=1, fig.align='center', fig.cap="Comparison between the estimated counts and the provided values.", fig.subcap=c("", "Log-log plot after removing 0 values.")>>=
ggplot(counts_comparison, aes(x=est, y=target)) + geom_point() + theme_classic()
new_counts <- counts_comparison[which(counts_comparison[c("est")] >= 1), ]
new_counts <- new_counts[which(new_counts[c("target")] >= 1), ]
ggplot(new_counts, aes(x=est, y=target)) + geom_point() + scale_x_log10() + scale_y_log10() + theme_classic()
@

\section{}

\subsection{Read coverage and library complexity}
To analyse the read coverage, we created the histogram in figure~\ref{fig:read-coverage}. We can see that the count values range from roughly 40 million to 180 million.
We can also see that most samples have more than 60 million reads, although a very small number has only around 40 million.
This might mean that in these samples lowly expressed genes are below the detection threshold. We can also see that there are a lot more genes with read counts in the 60 to 100 million range than in the rest of the domain, which indicates that we will probably need some kind of normalisation of the data.

<<read-coverage, fig.pos="ht", fig.width=5, fig.asp=1/2, fig.align='center', fig.cap="Read counts histogram.">>=
ggplot(counts_histogram, aes(x=counts)) + ylab("Absolute Frequency") + xlab("#reads") + geom_histogram(color="black", fill="white", bins=20) + theme_classic()
@

Library complexity refers to the number of unique DNA fragments present in a given library. To compute library complexity, we used a sampling-based approach. For tissue sample, we sampled the genes with probability proportional to the read count of each gene for that patient. In figure~\ref{fig:library-complexity} we plot the library complexities for all samples.
Analysing the figure we can see that, in general, in samples from normal tissues we hit more genes with fewer samples, which means that the genes are more uniformly represented. On the other hand, in deseased tissues, we get a lower percentage of all the detected genes with the same number of samples, showing that the read counts for the genes in deseased tissues is farther from a uniform distribution: there are a few genes with a much higher read count than the others.


<<library-complexity, fig.pos="ht", fig.asp=2/3, fig.align='center', fig.cap="Library complexity plot.", cache=TRUE>>=
# ggplot(data_g1, aes(x = value, group=key, color=tissue)) + stat_ecdf(geom="line") + scale_x_log10() + coord_cartesian(xlim=c(0,2000))

groups = as.numeric(substr(colnames(read_counts), nchar(colnames(read_counts))-1, nchar(colnames(read_counts))-1))
colors <- brewer.pal(3, "Dark2")

sample_n = 16
increment = 16000

list = c()
for (i in 1:sample_n) {
  list = append(list, c(length(unique(sample(rownames(read_counts), size=i*increment, prob=read_counts$TCGA.A1.A0SB.01, replace=TRUE))) / nrow(read_counts)))
}

plot(1:length(list) * increment, unlist(list), type="l", col=alpha(colors[groups[which(colnames(read_counts) == "TCGA.A1.A0SB.01")] + 1], 0.2), ylim=c(0,0.7), xlab="Number of Samples", ylab="Gene Coverage")

first = TRUE
for (person in colnames(read_counts)) {
  if (first) {
    first = FALSE
    next
  }
  list = c()
  for (i in 1:sample_n) {
    list = append(list, c(length(unique(sample(rownames(read_counts), size=i*increment, prob=read_counts[[person]], replace=TRUE))) / nrow(read_counts)))
  }
  lines(1:length(list) * increment, unlist(list), col=alpha(colors[groups[which(colnames(read_counts) == person)] + 1], 0.2), xlab="Number of Samples", ylab="Gene Coverage")
}
legend("bottomright", legend=c("Timor Sample", "Normal Sample"), col=brewer.pal(3, "Dark2"), fill=brewer.pal(3, "Dark2"), cex=0.8)
@

\subsection{Normalisation of the data}
To normalise the data, we used the Trimmed Mean of M (TMM) method. In order to evaluate our normalisation, we produced a series of plots which help us visualise how the data changed after the normalisation.

First, we plotted the histogram of the normalised read counts. When compared with the histogram resulting of the raw read counts (in figure~\ref{fig:read-coverage}), we can se that .....
% TODO MACF plot histogram of the normalised read counts (hopefully it is flatter)
\todo{MACF: plot histogram of the normalised read counts (hopefully it is flatter)}


We produced a plot where the distance between samples corresponds to the leading Biological Coefficient of Variation (BCV), using the function \texttt{plotMDS}. The result can be seen in figure~\ref{fig:mds}. There is a clear separation between the samples of normal tissues and the samples taken from tumours. It also appears that there are two distinct groups of samples from tumours.

Finally, we wanted to ensure that after normalisation there was no difference between the highly expressed and lowly expressed genes. To so so, we coloured the marks according to their read count.........

% TODO MACF different colours for 2 groups of genes with varying number read counts: produce histogram with the columns on the right in one color and the columns on the left another column (separate by mode/median=?). Then plotMDS using the same colours for the respetive marks.
\todo{MACF: different colours for 2 groups of genes with varying number read counts: produce histogram with the columns on the right in one color and the columns on the left another column (separate by mode/median=?). Then plotMDS using the same colours for the respetive marks.}

<<mds, fig.pos="ht", fig.width=5, fig.height=5, fig.align='center', fig.cap="Multidimensional Scaling plot of the data after normalizing.", cache=TRUE>>=
dge <- DGEList(counts=data.matrix(read_counts))

keep <- filterByExpr(dge)
dge <- dge[keep, , keep.lib.sizes=FALSE]

dge <- calcNormFactors(dge)

plotMDS(dge, pch=20, col = brewer.pal(3, "Dark2")[Tissue], gene.selection = "common")
legend("topleft", legend=c("Timor Sample", "Normal Sample"), col=brewer.pal(3, "Dark2"), fill=brewer.pal(3, "Dark2"), cex=0.8)
@

\subsection{Phenotypic traits and genes that dominate variance} % 2c)
  
% TODO MACF try to identify what separates the 2 groups of tumours in the MDS plot.
\todo{MACF: try to identify what separates the 2 groups of tumours in the MDS plot.}
\subsection{} % 2d)

\section{} % Group 3

\subsection{How well can genes recapitulate related immunohistochemistry tests} %3a)

We want to show how the gene expression for some genes relates to the binary classification for the related immunohistochemistry-based tests in the patient data. To do so, we produce 3 plots, showed in figure~\ref{fig:3a}.

First, in figure~\ref{fig:3a1} we have a scatter tissue sample the read count of ESR1 on the x-axis and the read count of ERS2 on the y-axis. Each mark is colored according to the presence of estrogen receptors in the respective tissue sample. We can see by this graph that the expression of ESR1 is highly related to the presence of estrogen receptors: the tissue samples with estrogen receptors tend to have higher read counts of ESR1. On the other hand, ESR2 appears to have little influence on the presence of estrogen receptors. We conclude ERS1's expression is very good at recapitulating the presence of estrogen receptors in a tissue sample, but the same is not true of ESR2.

Secondly, in figure~\ref{fig:3a2} we want to evaluate how PGR relates to the presence of progesterone receptors in tissue samples. Since we only have one gene to evaluate, we adopt a different approach: we used a histogram to plot the number of tissue samples we have (in the y-axis) against the read count of PGR. As we can see, the trend is for the tissue samples that test positive for the presence of progesterone receptors to have a higher read count of PGR, and for the the negative samples to have lower values.  We conclude PGR's expression is very good at recapitulating the presence of progesterone receptors in a tissue sample.

Finally, in figure~\ref{fig:3a3} we use a similar histogram to show the relation between the presence of HER2 protein in the tissue sample to the read count of ERBB2 gene.

<<3a, fig.pos='ht', fig.width=4.5, fig.height=2.5, fig.ncol=1, fig.align='center', fig.cap="Relation between the cognate genes and the immunohistochemistry-based tests.", fig.subcap=c('Relation between ESR1/ESR2 expression and the presence of estrogen receptors', 'Relation between PGR expression and the presence of progesterone receptors', 'Relation between ERBB2 expression and the presence of HER2 protein'), warning=FALSE>>=
ggplot(data_g3, aes(x=ESR1, y=ESR2, color=Estrogen)) + scale_color_brewer(palette="Dark2") + scale_y_log10() + scale_x_log10() + geom_point() + annotation_logticks() + theme_classic()
gghistogram(data_g3, x = "PGR", bins = 20,
            add = "mean", rug = TRUE,
            color = "Progesterone", fill = "Progesterone", xscale="log10", palette="Dark2")
gghistogram(data_g3, x = "ERBB2", bins = 20,
            add = "mean", rug = TRUE,
            color = "HER2", fill = "HER2", xscale="log10", palette="Dark2")
@

\todo{MACF: try to add ROC curves to these plots, or alternatively create another plot with ROC curves.}

\subsection{Survival analysis} %3b)
Just do the survival analysis according to the PAM50 groups.

<<survival, fig.pos="ht", fig.asp=1/2, fig.align='center', fig.cap="Hello">>=
time <- ifelse(is.na(DaysToDeath), LastFollowUp, DaysToDeath)

data = data.frame(Patient, Status, PAM50, DaysToDeath)

km_fit <- survfit(Surv(time, !is.na(DaysToDeath)) ~ PAM50, data=data)
autoplot(km_fit, conf.int.alpha=0.2, ylab="survival")+ scale_color_brewer(palette="Dark2") + scale_fill_brewer(palette="Dark2") + theme_classic()
@

\subsection{Gene signature that best classifies molecular subtypes} %3c)

<<fig.pos="ht", fig.align='center', fig.cap="Hello">>=
dge <- DGEList(counts=data.matrix(read_counts))
keep <- filterByExpr(dge)
dge <- dge[keep, , keep.lib.sizes=FALSE]
dge <- calcNormFactors(dge)

design <- model.matrix(~ addNA(PAM50))

v <- voom(dge,design,plot=TRUE)
linearfit = lmFit(v$E,design)
eBfit = eBayes(linearfit)
volcanoplot(eBfit,coef=2,style="B-statistic")

kable(topTable(eBfit,coef=2), format = "latex", booktabs = TRUE)
@

\subsection{Classifying molecular subtype} %3d)
\end{document}
